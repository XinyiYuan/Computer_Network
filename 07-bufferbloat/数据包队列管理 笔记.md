# 数据包队列管理 笔记

**路由表**Routing Table，aka路由择域信息库RIB，存储指向特定网络地址的路径。目的是实现路由协议和静态路由。

**转发信息库**FIB，概念上讲类似于路由表或信息库。

每个路由器中都有一个路由表和FIB表，路由表用来决策路由，FIB用来转发分组。

路由器的主要工作就是为经过路由器的每个数据包 `寻找一条最佳的传输路径` ，并将该数据 `有效地传送到目的站点` 。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据——路由表（Routing Table），供路由选择时使用，表中包含的信息决定了数据转发的策略。打个比方，路由表就像我们平时使用的地图一样，标识着各种路线，路由表中保存着子网的标志信息、网上路由器的个数和下一个路由器的名字等内容。路由表可以是由系统管理员固定设置好的，也可以由系统动态修改，可以由路由器自动调整，也可以由主机控制。



数据包队列的工作方式：Tail Drop和FIFO两种，通常组合使用，最常见

*其他队列管理机制：RED, WRED, CoDel, Choke, ......

队列应该设置为多大？经验法则 [Appenzeller2004] $ buffsize = RTT_{average} * C $，其中C为瓶颈链路带宽

多流环境下的队列大小：所有流的窗口大小之和复合高斯分布，队列大小分析？？没懂，结果是 $ BDP/\sqrt{n} $，其中BDP为在瓶颈带宽（路径中）传输的数据包的个数（$ RTT_{average} * C $）

现实中队列设置问题：队列过小 (under-buffered): 数据中心网络的TCP-Incast问题；队列过大 (over-buffered): 广域网边缘的BufferBloat问题

TCP-Incast问题：多个向一个发送，导致交换机出端口队列占满 [Phanishayee2008]

关键：多打一；队列小；传输中丢包重传效率低；业务性能取决于最慢的流

BufferBloat问题：数据包在队列中存留时间过长引起的延迟过大问题[Gettys2011]

原因：设备队列设置过大；TCP传输机制；队列管理机制

解决方法：1. 在队列满之前就主动（概率性的）丢包-RED (Random Early Detection)；2. 以延迟作为队列管理的信号-CoDel (Controlled Delay)。

RED (Random Early Detection)：队列满之前就开始主动概率性丢包，丢包概率与队列长度正相关。调参比较困难。

CoDel (Controlled Delay)：控制数据包在队列中的时间（延迟）（以此为度量指标），而不是队列长度。具体来说，当包停留时间超过target值时，将该数据包丢弃+根据control law设置下次丢包时间（$ interval / \sqrt{count} $ ），直到所有包的停留时间都小于target值。





实验过程：

读代码：parser.add_argument()

python之parser.add_argument()用法——命令行选项、参数和子命令解析器：https://blog.csdn.net/qq_34243930/article/details/106517985